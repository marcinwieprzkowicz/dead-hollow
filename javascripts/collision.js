// Generated by CoffeeScript 1.4.0

/*

Collision CoffeeScript class.
Really simple collision library, calculates the positions of solid element and doing some math stuff ;).
Provides two very useful methods: checkBetween & checkAll.

@author: Marcin Wieprzkowicz (marcin.wieprzkowicz@gmail.com)
*/


(function() {
  var Collision, getPosition,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  getPosition = function(obj) {
    var x, y;
    x = 0;
    y = 0;
    while (obj.offsetParent) {
      x += obj.offsetLeft;
      y += obj.offsetTop;
      if (obj.offsetParent.id === 'map') {
        break;
      }
      obj = obj.offsetParent;
    }
    return {
      x: x,
      y: y
    };
  };

  Collision = (function(_super) {

    __extends(Collision, _super);

    Collision.prototype.defaults = {
      elements: {
        solid: '#map .solid'
      }
    };

    function Collision(options, mapPosition) {
      this.mapPosition = mapPosition;
      Collision.__super__.constructor.apply(this, arguments);
      this.elements = {
        solid: document.querySelectorAll(this.options.elements.solid)
      };
      this.calcPositions(this.elements.solid);
    }

    Collision.prototype.calcPositions = function(el) {
      var current, i;
      if (el.length) {
        i = 0;
        while (i < el.length) {
          current = el[i];
          current.position = getPosition(current);
          i++;
        }
      } else {
        el.position = getPosition(el);
      }
    };

    Collision.prototype.checkBetween = function(firstEl, secondEl, shiftX, shiftY) {
      var bottom, left, right, top;
      left = Math.max(firstEl.position.x - this.mapPosition.x - shiftX, secondEl.position.x);
      right = Math.min(firstEl.position.x + firstEl.clientWidth - this.mapPosition.x - shiftX, secondEl.position.x + secondEl.clientWidth);
      bottom = Math.max(firstEl.position.y - this.mapPosition.y - shiftY, secondEl.position.y);
      top = Math.min(firstEl.position.y + firstEl.clientHeight - this.mapPosition.y - shiftY, secondEl.position.y + secondEl.clientHeight);
      return left < right && bottom < top;
    };

    Collision.prototype.checkAll = function(element, elements, shiftX, shiftY) {
      var handle, i;
      if (elements == null) {
        elements = this.elements.solid;
      }
      handle = {
        status: false
      };
      i = 0;
      while (true) {
        if (this.checkBetween(element, elements[i], shiftX, shiftY)) {
          handle = {
            status: true,
            element: elements[i]
          };
          break;
        } else if (i === elements.length - 1) {
          break;
        }
        i++;
      }
      return handle;
    };

    return Collision;

  })(Base);

  (typeof exports !== "undefined" && exports !== null ? exports : this).Collision = Collision;

}).call(this);
