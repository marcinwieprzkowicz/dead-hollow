// Generated by CoffeeScript 1.4.0

/*

Control CoffeeScript class.
Handles keyboard and touch events.

@author: Marcin Wieprzkowicz (marcin.wieprzkowicz@gmail.com)
*/


(function() {
  var Control,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Control = (function(_super) {

    __extends(Control, _super);

    Control.prototype.defaults = {
      touchItems: '.touch',
      control: {
        backward: '.control .backward',
        forward: '.control .forward',
        buttonB: '.control .buttonB',
        buttonA: '.control .buttonA',
        pause: '.control.pause a'
      }
    };

    function Control(options, game, map) {
      this.game = game;
      this.map = map;
      Control.__super__.constructor.apply(this, arguments);
      this.touchItems = document.querySelectorAll(this.options.touchItems);
      this.control = {
        backward: document.querySelector(this.options.control.backward),
        forward: document.querySelector(this.options.control.forward),
        buttonB: document.querySelector(this.options.control.buttonB),
        buttonA: document.querySelector(this.options.control.buttonA),
        pause: document.querySelector(this.options.control.pause)
      };
    }

    Control.prototype.addKeyboardEvents = function() {
      var movements,
        _this = this;
      movements = [
        {
          keys: 'right',
          on_keydown: function() {
            return _this.goRight();
          },
          on_keyup: function() {
            return _this.clearRight();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'left',
          on_keydown: function() {
            return _this.goLeft();
          },
          on_keyup: function() {
            return _this.clearRight();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'up',
          on_keydown: function() {
            return _this.goUp();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'space',
          on_keydown: function() {
            return _this.actionButton();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'escape',
          on_keydown: function() {
            return _this.pause();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'p',
          on_keydown: function() {
            return _this.pause();
          },
          prevent_repeat: true,
          prevent_default: true
        }
      ];
      keypress.register_many(movements);
    };

    Control.prototype.goRight = function() {
      var interval,
        _this = this;
      if (!this.game.paused) {
        this.map.clearAnimation('right');
        this.map.clearAnimation('left');
        interval = setInterval(function() {
          var collision;
          collision = _this.map.collision.checkAll(_this.map.objs.character.solid, null, -_this.map.options.animation.shift, 0);
          if (!collision.status && !_this.map.animations.right.stopped) {
            return _this.map.move(-_this.map.options.animation.shift, 0);
          }
        }, this.map.options.animation.duration);
        this.map.animations.right.interval = interval;
        this.map.objs.character.move();
      }
    };

    Control.prototype.clearRight = function() {
      this.map.clearAnimation('right');
      if (this.map.animations.left.interval == null) {
        this.map.objs.character.stop('run');
      }
    };

    Control.prototype.goLeft = function() {
      var interval,
        _this = this;
      if (!this.game.paused) {
        this.map.clearAnimation('right');
        this.map.clearAnimation('left');
        interval = setInterval(function() {
          var collision;
          collision = _this.map.collision.checkAll(_this.map.objs.character.solid, null, _this.map.options.animation.shift, 0);
          if (!collision.status && !_this.map.animations.left.stopped) {
            return _this.map.move(_this.map.options.animation.shift, 0);
          }
        }, this.map.options.animation.duration);
        this.map.animations.left.interval = interval;
        this.map.objs.character.move(true);
      }
    };

    Control.prototype.clearLeft = function() {
      this.map.clearAnimation('left');
      if (this.map.animations.right.interval == null) {
        this.map.objs.character.stop('run');
      }
    };

    Control.prototype.goUp = function() {
      var interval, t,
        _this = this;
      if (!(this.map.animations.up.interval != null) && !this.map.animations.up.stopped) {
        t = 0;
        interval = setInterval(function() {
          var y;
          if (!_this.game.paused) {
            y = Math.round(_this.map.objs.character.options.jump.force * _this.map.objs.character.options.jump.sinusAngle - _this.map.options.animation.gravity * t);
            _this.map.move(0, y);
            return t++;
          }
        }, this.map.options.animation.duration);
        this.map.animations.up.interval = interval;
      }
    };

    Control.prototype.actionButton = function() {
      var bgWall, doorCollision, fgWall, solid, solidCollision, solidElement, solidIndex, wallClass;
      if (!this.game.paused) {
        doorCollision = this.map.collision.checkAll(this.map.objs.character.solid, this.map.solid.doors, 0, 0);
        if (doorCollision.status) {
          wallClass = doorCollision.solid.element.className.match(/wall-\d+/g)[0];
          bgWall = document.querySelector("#background ." + wallClass);
          fgWall = document.querySelector("#foreground ." + wallClass);
          solidElement = fgWall.querySelector('.solid');
          solidIndex = parseInt(solidElement.getAttribute('data-index'), 10);
          solid = window.solids[solidIndex];
          solidCollision = this.map.collision.checkBetween(this.map.objs.character.solid, solid, 0, this.map.options.doorsRadius);
          if (!doorCollision.solid.element.classList.contains('pending') && !solidCollision.status) {
            bgWall.classList.toggle('open');
            bgWall.classList.add('pending');
            fgWall.classList.toggle('open');
            fgWall.classList.add('pending');
            solid.getHeightAgain();
            if (this.game.audio.openingDoors.getVolume() > 0) {
              return this.game.audio.openingDoors.play();
            }
          }
        }
      }
    };

    Control.prototype.showTouchItems = function() {
      var i, length;
      i = 0;
      length = this.touchItems.length;
      while (i < length) {
        this.touchItems[i].style.display = 'block';
        i++;
      }
    };

    Control.prototype.addControlEvents = function() {
      var controller, _i, _len, _ref,
        _this = this;
      _ref = this.control;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        controller = _ref[_i];
        this.preventLongPressMenu(controller);
      }
      this.addEvent(this.control.backward, 'touchstart', function() {
        document.body.onkeydown({
          keyCode: 37
        });
        return _this.control.backward.classList.add('touched');
      });
      this.addEvent(this.control.backward, 'touchend', function() {
        document.body.onkeyup({
          keyCode: 37
        });
        return _this.control.backward.classList.remove('touched');
      });
      this.addEvent(this.control.forward, 'touchstart', function() {
        document.body.onkeydown({
          keyCode: 39
        });
        return _this.control.forward.classList.add('touched');
      });
      this.addEvent(this.control.forward, 'touchend', function() {
        document.body.onkeyup({
          keyCode: 39
        });
        return _this.control.forward.classList.remove('touched');
      });
      this.addEvent(this.control.buttonB, 'touchstart', function() {
        document.body.onkeydown({
          keyCode: 38
        });
        return _this.control.buttonB.classList.add('touched');
      });
      this.addEvent(this.control.buttonB, 'touchend', function() {
        document.body.onkeyup({
          keyCode: 38
        });
        return _this.control.buttonB.classList.remove('touched');
      });
      this.addEvent(this.control.buttonA, 'touchstart', function() {
        document.body.onkeydown({
          keyCode: 32
        });
        return _this.control.buttonA.classList.add('touched');
      });
      this.addEvent(this.control.buttonA, 'touchend', function() {
        document.body.onkeyup({
          keyCode: 32
        });
        return _this.control.buttonA.classList.remove('touched');
      });
      this.addEvent(this.control.pause, 'touchstart', function() {
        document.body.onkeydown({
          keyCode: 27
        });
        return _this.control.pause.classList.add('touched');
      });
      this.addEvent(this.control.pause, 'touchend', function() {
        document.body.onkeyup({
          keyCode: 27
        });
        return _this.control.pause.classList.remove('touched');
      });
    };

    Control.prototype.pause = function() {
      if (this.game.paused) {
        this.game.start();
      } else {
        this.game.pause();
        this.fadeIn(this.game.element.game.overlay);
        this.fadeIn(this.game.menu.element.main.element);
      }
    };

    return Control;

  })(Base);

  (typeof exports !== "undefined" && exports !== null ? exports : this).Control = Control;

}).call(this);
