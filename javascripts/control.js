// Generated by CoffeeScript 1.4.0

/*

Control CoffeeScript class.
Handles keyboard and touch events.

@author: Marcin Wieprzkowicz (marcin.wieprzkowicz@gmail.com)
*/


(function() {
  var Control,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Control = (function(_super) {

    __extends(Control, _super);

    Control.prototype.defaults = {
      touchItems: '.touch',
      control: {
        backward: '.control .backward',
        forward: '.control .forward',
        buttonB: '.control .buttonB',
        buttonA: '.control .buttonA',
        pause: '.control.pause a'
      }
    };

    function Control(options, game, map) {
      this.game = game;
      this.map = map;
      Control.__super__.constructor.apply(this, arguments);
      this.touchItems = document.querySelectorAll(this.options.touchItems);
      this.control = {
        backward: document.querySelector(this.options.control.backward),
        forward: document.querySelector(this.options.control.forward),
        buttonB: document.querySelector(this.options.control.buttonB),
        buttonA: document.querySelector(this.options.control.buttonA),
        pause: document.querySelector(this.options.control.pause)
      };
    }

    Control.prototype.addKeyboardEvents = function() {
      var movements,
        _this = this;
      movements = [
        {
          keys: 'right',
          on_keydown: function() {
            return _this.globals.movement.forward = 1;
          },
          on_keyup: function() {
            return _this.globals.movement.forward = 0;
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'left',
          on_keydown: function() {
            return _this.globals.movement.backward = 1;
          },
          on_keyup: function() {
            return _this.globals.movement.backward = 0;
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'up',
          on_keydown: function() {
            return _this.globals.movement.up = 1;
          },
          on_keyup: function() {
            return _this.globals.movement.up = 0;
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'space',
          on_keydown: function() {
            return _this.actionButton();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'escape',
          on_keydown: function() {
            return _this.pause();
          },
          prevent_repeat: true,
          prevent_default: true
        }, {
          keys: 'p',
          on_keydown: function() {
            return _this.pause();
          },
          prevent_repeat: true,
          prevent_default: true
        }
      ];
      keypress.register_many(movements);
      return this;
    };

    Control.prototype.actionButton = function() {
      var bgWall, doorCollision, fgWall, solid, solidCollision, solidElement, solidIndex, wallClass;
      if (!this.globals.pause) {
        doorCollision = this.map.collision.checkAll(this.map.objs.character.solid, this.map.solid.doors, 0, 0);
        if (doorCollision.status) {
          wallClass = doorCollision.solid.element.className.match(/wall-\d+/g)[0];
          bgWall = document.querySelector("#background ." + wallClass);
          fgWall = document.querySelector("#foreground ." + wallClass);
          solidElement = fgWall.querySelector('.solid');
          solidIndex = parseInt(solidElement.getAttribute('data-index'), 10);
          solid = this.globals.solids[solidIndex];
          solidCollision = this.map.collision.checkBetween(this.map.objs.character.solid, solid, 0, this.map.options.doorsRadius);
          if (!doorCollision.solid.element.classList.contains('pending') && !solidCollision.status) {
            bgWall.classList.toggle('open');
            bgWall.classList.add('pending');
            fgWall.classList.toggle('open');
            fgWall.classList.add('pending');
            solid.getHeightAgain();
            if (this.game.audio.openingDoors.getVolume() > 0) {
              this.game.audio.openingDoors.play();
            }
          }
        }
      }
      return this;
    };

    Control.prototype.showTouchItems = function() {
      var item, _i, _len, _ref;
      _ref = this.touchItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.style.display = 'block';
      }
      return this;
    };

    Control.prototype.addControlEvents = function() {
      var _this = this;
      this.addEvent(this.control.backward, 'touchstart', function() {
        return _this.globals.movement.backward = 1;
      });
      this.addEvent(this.control.backward, 'touchend', function() {
        return _this.globals.movement.backward = 0;
      });
      this.addEvent(this.control.forward, 'touchstart', function() {
        return _this.globals.movement.forward = 1;
      });
      this.addEvent(this.control.forward, 'touchend', function() {
        return _this.globals.movement.forward = 0;
      });
      this.addEvent(this.control.buttonB, 'touchstart', function() {
        return _this.globals.movement.up = 1;
      });
      this.addEvent(this.control.buttonB, 'touchend', function() {
        return _this.globals.movement.up = 0;
      });
      this.addEvent(this.control.buttonA, 'touchstart', function() {
        return _this.actionButton();
      });
      this.addEvent(this.control.pause, 'touchstart', function() {
        return _this.pause();
      });
      return this;
    };

    Control.prototype.pause = function() {
      if (this.globals.pause) {
        this.game.start();
      } else {
        this.game.pause();
        this.fadeIn(this.game.element.game.overlay);
        this.fadeIn(this.game.menu.element.main.element);
      }
      return this;
    };

    return Control;

  })(Base);

  (typeof exports !== "undefined" && exports !== null ? exports : this).Control = Control;

}).call(this);
